<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS function</title>
</head>

<body>

    <h2>JavaScript Function Closures</h2>
    <p>Counting with a local variable.</p>

    <p id="demo">0</p>

    <script>
        /*
            1. add function : function을 리턴함.
                => higer order function : function의 parameter로 function을 대입하거나, function을 리턴함.
            2. IIFE(Immediately Inviked Function Expression)
                : function을 선언함과 동시에 즉시 실행 
                -> (funtion(){})()
            3. add  = function() {counter += 1; return counter;};
                => add의 부모의 function에서 선언된 메모리에 존재하는 counter 변수에 대하여 연결고리를JS엔진이 만들어줌.
                => add() 함수를 실행할 때, 연결고리를 가진 부모function에서 선언된 counter변수의 값을 계속 변경 가능하게 만듦.
                    
                    +) Java의 private으로 선언된 변수를 관리하는 효과를 갖음.
                        - counter값은 오직 add()함수를 실행할 때만 변경 가능하다는 의미.
                        (기타 다른 방법으로 counter변수값을 직접 수정 불가함.)
                        => 부모function에서 선언된 변수를 자식 함수에서 사용함으로서 자식 함수에만 부모의 변수를 사용하는 겻을 closure(폐쇄,포함)라고함.
                            - 수학에서 close와 같은 개념임.

            4. closure 성립 조건
                1) 부모 function에서 자식 function을 return.(high order function)
                2) 부모 function에서 선언된 변수를 자식 function에서 사용.
            5. closure 효과
                : 부모 function에서 선언된 변수를 private scope으로 사용 가능함.
        */
        const add = (function () {
            let counter = 0;
            return function () { counter += 1; return counter; }
        })();

        function myFunction() {
            document.getElementById("demo").innerHTML = add();
        }
    </script>


</body>

</html>